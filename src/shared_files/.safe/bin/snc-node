#!/bin/bash

# turn on bash's job control
set -m

PROG_NAME=run_safenode

SHORT_OPTS=hVv
LONG_OPTS="name:,log-level:,num-nodes:,\
skip-auto-port-forwarding:,\
con-ip:,con-port:,pub-ip:,pub-port:,\
idle-timeout-msec:,keep-alive-interval-msec:,\
log-dir:,root-dir:,first:,version,help"

FIRST=false
LOG_LEVEL=error
NUM_NODES=1
IDLE_TIMEOUT_MSEC=4000
KEEP_ALIVE_INTERVAL_MSEC=5500
IP_NUMBER=0

RE_NUMBER='^[0-9]+$'
RE_IPV4='^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
RE_IPV6='^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$'

help()
{
  sn_node --help
  exit 2
}

version()
{
  echo "Podman run script for safenode v1.0"
  exit 2
}

usage()
{
  echo "Usage: run_safenode [ --name NETWORK_NAME ] 
    [ --log-level LOG_LEVEL ]
    [ --num-nodes NUM_NODES ]
    [ --skip-auto-port-forwarding SKIP_AUTO_PORT_FORWARDING ]
    [ --idle-timeout-msec IDLE_TIMEOUT_MSEC ]
    [ --keep-alive-interval-msec KEEP_ALIVE_INTERVAL_MSEC ]
    [ --con-ip CON_IP ] 
    [ --con-port CON_PORT ]
    [ --pub-ip PUB_IP ]
    [ --pub-port PUB_PORT ]
    [ --log-dir LOG_DIR ]
    [ --root-dir ROOT_DIR ]
    [ --first FIRST ]"
  exit 2
}

next_ipv4() {
  IP=$1
  IP_VALUES=(${IP//"."/ })
  for ((i=$((${#IP_VALUES[@]}-1)); i >=0; i--)); do
    IP_VALUES[$i]=$((${IP_VALUES[$i]} + 1)) 
    if [ ${IP_VALUES[$i]} -gt 255 ]; then
      IP_VALUES[$i]=0
    else
      break
    fi
  done
  NEXT_IP=$(printf '%d.%d.%d.%d\n' `echo ${IP_VALUES[@]}`)
  echo "$NEXT_IP"
}

next_ipv6() {
  IP=$(expand_ipv6 $1)
  IP_VALUES=(${IP//":"/ })
  for ((i=$((${#IP_VALUES[@]}-1)); i >=0; i--)); do
    IP_VALUES[$i]=$(printf "%x\n" $((16#${IP_VALUES[$i]} + 1))) 
    if [[ 0x${IP_VALUES[$i]} -gt 0xffff ]]; then
      IP_VALUES[$i]=0
    else
      break
    fi
  done
  NEXT_IP=$(printf '%s:%s:%s:%s:%s:%s:%s:%s\n' `echo ${IP_VALUES[*]}`)
  echo "$NEXT_IP"
}

# helper to convert hex to dec (portable version)
hex2dec(){
    [ "$1" != "" ] && printf "%d" "$(( 0x$1 ))"
}

expand_ipv6() {
    ip=$1

    # prepend 0 if we start with :
    echo $ip | grep -qs "^:" && ip="0${ip}"

    # expand ::
    if echo $ip | grep -qs "::"; then
        colons=$(echo $ip | sed 's/[^:]//g')
        missing=$(echo ":::::::::" | sed "s/$colons//")
        expanded=$(echo $missing | sed 's/:/:0/g')
        ip=$(echo $ip | sed "s/::/$expanded/")
    fi

    blocks=$(echo $ip | grep -o "[0-9a-f]\+")
    set $blocks

    printf "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n" \
        $(hex2dec $1) \
        $(hex2dec $2) \
        $(hex2dec $3) \
        $(hex2dec $4) \
        $(hex2dec $5) \
        $(hex2dec $6) \
        $(hex2dec $7) \
        $(hex2dec $8)
}

# returns a compressed ipv6 address under the form recommended by RFC5952
compress_ipv6() {
    ip=$1

    blocks=$(echo $ip | grep -o "[0-9a-f]\+")
    set $blocks

    # compress leading zeros
    ip=$(printf "%x:%x:%x:%x:%x:%x:%x:%x\n" \
        $(hex2dec $1) \
        $(hex2dec $2) \
        $(hex2dec $3) \
        $(hex2dec $4) \
        $(hex2dec $5) \
        $(hex2dec $6) \
        $(hex2dec $7) \
        $(hex2dec $8)
    )

    # prepend : for easier matching
    ip=:$ip

    # :: must compress the longest chain
    for pattern in :0:0:0:0:0:0:0:0 \
            :0:0:0:0:0:0:0 \
            :0:0:0:0:0:0 \
            :0:0:0:0:0 \
            :0:0:0:0 \
            :0:0; do
        if echo $ip | grep -qs $pattern; then
            ip=$(echo $ip | sed "s/$pattern/::/")
            # if the substitution occured before the end, we have :::
            ip=$(echo $ip | sed 's/:::/::/')
            break # only one substitution
        fi
    done

    # remove prepending : if necessary
    echo $ip | grep -qs "^:[^:]" && ip=$(echo $ip | sed 's/://')

    echo $ip
}

PARSED_ARGUMENTS=$(getopt -o $SHORT_OPTS --longoptions $LONG_OPTS --name $PROG_NAME -- "$@")

VALID_ARGUMENTS=$?
if [ "$VALID_ARGUMENTS" != "0" ]; then
  usage
fi

eval set -- "$PARSED_ARGUMENTS"
while : 
do
  case "$1" in 
    --name) NETWORK_NAME="$2"; shift 2;;
    --log-level) LOG_LEVEL="$2"; shift 2;;
    --num-nodes) NUM_NODES="$2"; shift 2;;
    --skip-auto-port-forwarding) SKIP_AUTO_PORT_FORWARDING="$2"; shift 2;;
    --idle-timeout-msec) IDLE_TIMEOUT_MSEC="$2"; shift 2;;
    --keep-alive-interval-msec) KEEP_ALIVE_INTERVAL_MSEC="$2"; shift 2;;
    --con-ip) CON_IP="$2"; shift 2;;
    --con-port) CON_PORT="$2"; shift 2;;
    --pub-ip) PUB_IP="$2"; shift 2;;
    --pub-port) PUB_PORT="$2"; shift 2;;
    --log-dir) LOG_DIR="$2"; shift 2;;
    --root-dir) ROOT_DIR="$2"; shift 2;;
    --first) FIRST="$2"; shift 2;;
    -h | --help) help ;;
    -v | --version) version ;;
    --) shift; break ;;
    *) echo "Unexpected option: $1 - this should not happen."
       usage ;;
  esac
done

case $LOG_LEVEL in
  "warn") VERBOSE_OPT=" -v";;
  "info") VERBOSE_OPT=" -vv" ;;
  "debug") VERBOSE_OPT=" -vvv" ;;
  "trace") VERBOSE_OPT=" -vvvv" ;;
esac

if [ "$SKIP_AUTO_PORT_FORWARDING" = true ]; then
  SKIP_AUTO_PORT_FORWARDING_OPT=" --skip-auto-port-forwarding"
fi

if [[ $IDLE_TIMEOUT_MSEC =~ $RE_NUMBER ]]; then
  IDLE_TIMEOUT_MSEC_OPT=" --idle-timeout-msec ${IDLE_TIMEOUT_MSEC}" 
fi

if [[ $KEEP_ALIVE_INTERVAL_MSEC =~ $RE_NUMBER ]]; then
  KEEP_ALIVE_INTERVAL_MSEC_OPT=" --keep-alive-interval-msec ${KEEP_ALIVE_INTERVAL_MSEC}" 
fi

if [ -n "$LOG_DIR" ]; then
  LOG_DIR_OPT=" --log-dir ${LOG_DIR}" 
fi

if [ -n "$ROOT_DIR" ]; then
  ROOT_DIR_OPT=" --root-dir ${ROOT_DIR}" 
fi

CON_OPT=" --local-addr ${CON_IP}:${CON_PORT}"
PUB_OPT=" --public-addr ${PUB_IP}:${PUB_PORT}"

if [ "$FIRST" = true ]; then
  RUST_BACKTRACE=full COLORBT_SHOW_HIDDEN=1 sn_node\
  ${VERBOSE_OPT}${IDLE_TIMEOUT_MSEC_OPT}${KEEP_ALIVE_INTERVAL_MSEC_OPT}${SKIP_AUTO_PORT_FORWARDING_OPT}\
  ${CON_OPT}${PUB_OPT}${LOG_DIR_OPT}${ROOT_DIR_OPT} --first &
  safe networks add ${NETWORK_NAME}
  safe networks switch ${NETWORK_NAME}
else
  safe networks switch ${NETWORK_NAME}
  RUST_BACKTRACE=full COLORBT_SHOW_HIDDEN=1 sn_node\
  ${VERBOSE_OPT}${IDLE_TIMEOUT_MSEC_OPT}${KEEP_ALIVE_INTERVAL_MSEC_OPT}${SKIP_AUTO_PORT_FORWARDING_OPT}\
  ${CON_OPT}${PUB_OPT}${LOG_DIR_OPT}${ROOT_DIR_OPT} &
fi
NUM_NODES=$(($NUM_NODES -1))

if [ $NUM_NODES -ne 0 ]; then
  
  LOG_DIR_BASE=${LOG_DIR%/*}
  ROOT_DIR_BASE=${ROOT_DIR%/*}

  for (( i = 0; i < NUM_NODES; i++ ))
    do
      
    if [[ $CON_IP =~ $RE_IPV4 ]]; then
      CON_IP=$(next_ipv4 $CON_IP) 
    elif [[ $CON_IP =~ $RE_IPV6 ]]; then    
      CON_IP=$(next_ipv6 $CON_IP) 
    fi

    CON_OPT=" --local-addr ${CON_IP}:${CON_PORT}"
    PUB_OPT=" --public-addr ${PUB_IP}:$(($PUB_PORT + $i))"

    LOG_DIR_OPT=" --log-dir ${LOG_DIR_BASE}/node_dir_$i"
    ROOT_DIR_OPT=" --root-dir ${ROOT_DIR_BASE}/node_dir_$i" 

    RUST_BACKTRACE=full COLORBT_SHOW_HIDDEN=1 sn_node\
    ${VERBOSE_OPT}${IDLE_TIMEOUT_MSEC_OPT}${KEEP_ALIVE_INTERVAL_MSEC_OPT}${SKIP_AUTO_PORT_FORWARDING_OPT}\
    ${CON_OPT}${PUB_OPT}${LOG_DIR_OPT}${ROOT_DIR_OPT} &

  done
fi

# now we bring the primary process back into the foreground
# and leave it there
fg %1
